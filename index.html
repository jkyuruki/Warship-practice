<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Three Lane Tap Game (Timed + Golden)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #111;
        color: #fff;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        height: 100%;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #gameContainer {
        position: relative;
        width: min(420px, 100vw);
        height: min(720px, 100vh);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0,0,0,0.7);
        background: #000;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
    }

    #hud {
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        display: flex;
        justify-content: space-between;
        font-size: 14px;
        pointer-events: none;
        text-shadow: 0 0 4px rgba(0,0,0,0.9);
    }

    #startScreen, #gameOverScreen {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.95));
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 24px;
        box-sizing: border-box;
    }

    h1 {
        margin: 0 0 12px;
        font-size: 24px;
        letter-spacing: 0.03em;
    }

    p {
        margin: 6px 0;
        font-size: 14px;
        opacity: 0.85;
    }

    button {
        margin-top: 16px;
        padding: 10px 18px;
        font-size: 15px;
        font-weight: 600;
        border-radius: 999px;
        border: none;
        cursor: pointer;
        background: #26c6da;
        color: #000;
        box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }

    button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }

    .hint {
        margin-top: 10px;
        font-size: 12px;
        opacity: 0.7;
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div>Score: <span id="scoreText">0</span></div>
        <div>Misses: <span id="missText">0</span> | 30s game</div>
    </div>

    <div id="startScreen">
        <h1>3-Lane Tap</h1>
        <p>30-second run. Miss only when circles fall off the bottom.</p>
        <p>5 normal hits in a row spawns a faster golden circle with the next one.</p>
        <button id="startButton">Start</button>
        <div class="hint">Mobile: release in the lane • Desktop: click or press A / S / D</div>
    </div>

    <div id="gameOverScreen" style="display:none;">
        <h1>Time's Up!</h1>
        <p>Your score: <span id="finalScore">0</span></p>
        <p>Misses: <span id="finalMisses">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>
</div>

<script>
(function () {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const hudScore = document.getElementById('scoreText');
    const hudMiss  = document.getElementById('missText');

    const startScreen    = document.getElementById('startScreen');
    const startButton    = document.getElementById('startButton');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const restartButton  = document.getElementById('restartButton');
    const finalScoreEl   = document.getElementById('finalScore');
    const finalMissesEl  = document.getElementById('finalMisses');

    let width = 360;
    let height = 640;

    function resizeCanvas() {
        canvas.width = width;
        canvas.height = height;
    }
    resizeCanvas();

    /* --- Audio --- */
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (AC) {
                audioCtx = new AC();
            }
        }
    }

    function beep(freq, duration, type='sine', gain=0.25) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        g.gain.value = gain;
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(g).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function hitSound()  { beep(880, 0.05, 'square', 0.4); }
    function missSound() { beep(220, 0.12, 'sawtooth', 0.4); }

    /* --- Game State --- */
    const GAME_DURATION = 30; // seconds
    const TAP_COOLDOWN  = 0.5; // seconds per lane
    const SPAWN_DELAY   = 0.8; // seconds between normal circles

    let running = false;
    let score = 0;
    let misses = 0;
    let gameStartTime = 0;

    const lanes = 3;
    const laneWidth = () => width / lanes;
    const zoneHeight = 120;
    const zoneTop = () => height - zoneHeight;
    const circleRadius = 26;

    // Circles array (normal & golden)
    // { lane, x, y, vy, isGolden }
    let circles = [];
    let lastLane = -1;

    // Streak & golden mechanic
    let normalStreak = 0;
    let goldenPending = false;

    // Per-lane cooldown + hit flash + cooldown visibility
    let laneCooldownUntil        = [0, 0, 0]; // logical cooldown end time
    let laneCooldownVisibleUntil = [0, 0, 0]; // red shown only until this time
    let laneHitFlashUntil        = [0, 0, 0]; // green flash time

    // Next normal spawn timing
    let nextNormalSpawnTime = null; // in seconds

    // Timer bookkeeping
    let lastTime = 0;

    // NEW: time+score based speed curve
    function speedCurve(nowSec, score) {
        const elapsed = Math.max(0, Math.min(GAME_DURATION, nowSec - gameStartTime));
        const t = elapsed / GAME_DURATION; // 0 → 1 over 30s

        // Base ramps from ~360 px/s to ~780+ px/s over the game
        const base = 380 + 800 * Math.pow(t, 2.1);

        // Small skill-based bump (good players get a bit more speed)
        const skillTerm = Math.min(score, 25) * 6; // up to +150

        const jitter = (Math.random() - 0.5) * 40;
        return base + skillTerm + jitter;
    }

    function spawnNormalCircle(nowSec) {
        let lane;
        do {
            lane = Math.floor(Math.random() * lanes);
        } while (lane === lastLane && lanes > 1);

        lastLane = lane;

        const speed = speedCurve(nowSec, score);
        const circle = {
            lane,
            x: lane * laneWidth() + laneWidth() / 2,
            y: -circleRadius * 1.5,
            vy: speed,
            isGolden: false
        };
        circles.push(circle);

        // If a special golden is pending, spawn it now in another lane
        if (goldenPending) {
            spawnGoldenCircle(speed, lane);
            goldenPending = false;
        }
    }

    function spawnGoldenCircle(normalSpeed, normalLane) {
        const candidates = [];
        for (let i = 0; i < lanes; i++) {
            if (i !== normalLane) candidates.push(i);
        }
        const lane = candidates[Math.floor(Math.random() * candidates.length)];
        const speed = normalSpeed * 1.15; // 15% faster than the linked normal

        const circle = {
            lane,
            x: lane * laneWidth() + laneWidth() / 2,
            y: -circleRadius * 1.5,
            vy: speed,
            isGolden: true
        };
        circles.push(circle);
    }

    function startGame() {
        initAudio();
        running = true;
        score = 0;
        misses = 0;
        normalStreak = 0;
        goldenPending = false;
        laneCooldownUntil        = [0, 0, 0];
        laneCooldownVisibleUntil = [0, 0, 0];
        laneHitFlashUntil        = [0, 0, 0];
        circles = [];
        lastLane = -1;
        nextNormalSpawnTime = null;

        hudScore.textContent = score;
        hudMiss.textContent  = misses + " | 30s game";

        startScreen.style.display    = 'none';
        gameOverScreen.style.display = 'none';

        gameStartTime = performance.now() / 1000;
        lastTime = performance.now();

        // First normal circle appears immediately
        spawnNormalCircle(gameStartTime);

        requestAnimationFrame(loop);
    }

    function endGame() {
        running = false;
        finalScoreEl.textContent   = score;
        finalMissesEl.textContent  = misses;
        gameOverScreen.style.display = 'flex';
    }

    function isCircleInHitWindow(circle) {
        const top = zoneTop() + 10;
        const bottom = height - 10;
        return (
            circle.y + circleRadius >= top &&
            circle.y - circleRadius <= bottom
        );
    }

    function removeCircle(circle) {
        const idx = circles.indexOf(circle);
        if (idx !== -1) circles.splice(idx, 1);
    }

    function scheduleNextNormal(nowSec) {
        nextNormalSpawnTime = nowSec + SPAWN_DELAY;
    }

    function registerHit(circle, lane, nowSec) {
        score++;
        hudScore.textContent = score;
        hitSound();

        // Green flash: visually overrides any red
        laneHitFlashUntil[lane] = nowSec + 0.15;

        // This hit's cooldown should NOT show red at all
        laneCooldownVisibleUntil[lane] = 0;

        // Streak only cares about normal circles
        if (!circle.isGolden) {
            normalStreak++;
            if (normalStreak >= 5) {
                goldenPending = true;
                normalStreak = 0;
            }
        }

        removeCircle(circle);

        // Normal circle: delay before next normal spawn
        if (!circle.isGolden) {
            scheduleNextNormal(nowSec);
        }
    }

    function registerMiss(circle, nowSec) {
        misses++;
        hudMiss.textContent = misses + " | 30s game";
        missSound();

        // Streak resets only for missed normal circles
        if (!circle.isGolden) {
            normalStreak = 0;
        }

        removeCircle(circle);

        // If we missed a normal circle, delay next normal spawn
        if (!circle.isGolden) {
            scheduleNextNormal(nowSec);
        }
    }

    function handleLaneTap(lane) {
        if (!running) return;

        const nowSec = performance.now() / 1000;

        // 1) Cooldown gate: if lane cooling, nothing happens
        if (nowSec < laneCooldownUntil[lane]) {
            return;
        }

        // 2) Apply cooldown for this attempt
        laneCooldownUntil[lane]        = nowSec + TAP_COOLDOWN;
        laneCooldownVisibleUntil[lane] = laneCooldownUntil[lane];

        // 3) Check for hittable circle in this lane
        let hitCircle = null;
        for (let i = 0; i < circles.length; i++) {
            const c = circles[i];
            if (c.lane !== lane) continue;
            if (isCircleInHitWindow(c)) {
                hitCircle = c;
                break; // at most one per lane
            }
        }

        if (hitCircle) {
            registerHit(hitCircle, lane, nowSec);
        }
        // If no hittable circle: early/late tap → cooldown only, no miss.
    }

    /* --- Input --- */

    // Mouse: score on mouseup (so it behaves similar to release on mobile)
    function handleMouseUp(event) {
        initAudio();
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) * (width / rect.width);
        const y = (event.clientY - rect.top) * (height / rect.height);
        if (y >= zoneTop() - 20) {
            const lane = Math.floor(x / laneWidth());
            handleLaneTap(lane);
        }
    }

    // Touch: score on touchend; supports both quick taps and hold+release
    function handleTouchEnd(event) {
        initAudio();
        const t = event.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        const x = (t.clientX - rect.left) * (width / rect.width);
        const y = (t.clientY - rect.top) * (height / rect.height);
        if (y >= zoneTop() - 20) {
            const lane = Math.floor(x / laneWidth());
            handleLaneTap(lane);
        }
        event.preventDefault();
    }

    function handleKey(event) {
        if (!running) return;
        initAudio();
        if (event.key === 'a' || event.key === 'A') handleLaneTap(0);
        if (event.key === 's' || event.key === 'S') handleLaneTap(1);
        if (event.key === 'd' || event.key === 'D') handleLaneTap(2);
    }

    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('touchend', handleTouchEnd, { passive:false });
    window.addEventListener('keydown', handleKey);
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);

    /* --- Loop --- */
    function loop(timestamp) {
        if (!running) return;
        const nowSec = timestamp / 1000;

        // Check time limit
        const elapsed = nowSec - gameStartTime;
        if (elapsed >= GAME_DURATION) {
            draw(nowSec);
            endGame();
            return;
        }

        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        update(dt, nowSec);
        draw(nowSec);

        requestAnimationFrame(loop);
    }

    function update(dt, nowSec) {
        // Move circles & detect misses (falling off bottom)
        for (let i = circles.length - 1; i >= 0; i--) {
            const c = circles[i];
            c.y += c.vy * dt;

            if (c.y - circleRadius > height) {
                registerMiss(c, nowSec);
            }
        }

        // Spawn next normal circle after delay, if needed
        const hasNormal = circles.some(c => !c.isGolden);
        if (!hasNormal && nextNormalSpawnTime !== null && nowSec >= nextNormalSpawnTime && running) {
            spawnNormalCircle(nowSec);
            nextNormalSpawnTime = null;
        }
    }

    function draw(nowSec) {
        ctx.clearRect(0, 0, width, height);

        // Background
        const grad = ctx.createLinearGradient(0,0,0,height);
        grad.addColorStop(0, '#000');
        grad.addColorStop(1, '#111');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,width,height);

        // Lane separators
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 2;
        for (let i = 1; i < lanes; i++) {
            const x = i * laneWidth();
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }

        // General hit zone band
        ctx.fillStyle = 'rgba(255,255,255,0.04)';
        ctx.fillRect(0, zoneTop(), width, zoneHeight);

        // Per-lane hit zone boxes
        for (let lane = 0; lane < lanes; lane++) {
            const x0 = lane * laneWidth() + 4;
            const y0 = zoneTop() + 4;
            const w  = laneWidth() - 8;
            const h  = zoneHeight - 8;

            if (nowSec < laneHitFlashUntil[lane]) {
                // Green flash for hit
                ctx.fillStyle = 'rgba(76, 175, 80, 0.85)';
                ctx.fillRect(x0, y0, w, h);
                ctx.strokeStyle = 'rgba(76,175,80,1.0)';
                ctx.lineWidth = 3;
                ctx.strokeRect(x0, y0, w, h);
            } else if (nowSec < laneCooldownVisibleUntil[lane]) {
                // Red cooldown (only for non-hit attempts)
                ctx.fillStyle = 'rgba(244, 67, 54, 0.65)';
                ctx.fillRect(x0, y0, w, h);
                ctx.strokeStyle = 'rgba(244, 67, 54, 1.0)';
                ctx.lineWidth = 3;
                ctx.strokeRect(x0, y0, w, h);
            } else {
                // Normal outline
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x0, y0, w, h);
            }
        }

        // Circles (normal & golden)
        for (const c of circles) {
            if (c.isGolden) {
                const gradG = ctx.createRadialGradient(
                    c.x, c.y, 5,
                    c.x, c.y, circleRadius
                );
                gradG.addColorStop(0, '#fff59d');
                gradG.addColorStop(0.5, '#ffeb3b');
                gradG.addColorStop(1, '#fbc02d');
                ctx.fillStyle = gradG;
            } else {
                const colors = ['#26c6da','#66bb6a','#ffca28'];
                ctx.fillStyle = colors[c.lane];
            }

            ctx.beginPath();
            ctx.arc(c.x, c.y, circleRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }

    // Initial static frame
    draw(performance.now() / 1000);
})();
</script>
</body>
</html>
