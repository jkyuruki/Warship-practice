<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Three Lane Tap Game (Cooldown + Hit Flash)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #111;
        color: #fff;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        height: 100%;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #gameContainer {
        position: relative;
        width: min(420px, 100vw);
        height: min(720px, 100vh);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0,0,0,0.7);
        background: #000;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
    }

    #hud {
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        display: flex;
        justify-content: space-between;
        font-size: 14px;
        pointer-events: none;
        text-shadow: 0 0 4px rgba(0,0,0,0.9);
    }

    #startScreen {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.95));
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 24px;
        box-sizing: border-box;
    }

    button {
        padding: 10px 18px;
        font-size: 15px;
        font-weight: 600;
        border-radius: 999px;
        border: none;
        cursor: pointer;
        background: #26c6da;
        color: #000;
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div>Score: <span id="scoreText">0</span></div>
        <div>Misses: <span id="missText">0</span></div>
    </div>

    <div id="startScreen">
        <h1>3-Lane Tap</h1>
        <p>Miss only when a circle falls past the bottom.</p>
        <p>Cooldown per lane, and green flash on hits.</p>
        <button id="startButton">Start</button>
    </div>
</div>

<script>
(function () {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const hudScore = document.getElementById('scoreText');
    const hudMiss  = document.getElementById('missText');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');

    let width = 360;
    let height = 640;

    function resizeCanvas() {
        canvas.width = width;
        canvas.height = height;
    }
    resizeCanvas();

    /** AUDIO SYSTEM **/
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AC();
        }
    }

    function beep(freq, duration, type='sine', gain=0.25) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        g.gain.value = gain;
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(g).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function hitSound()  { beep(880, 0.05, 'square', 0.4); }
    function missSound() { beep(220, 0.12, 'sawtooth', 0.4); }

    /** GAME STATE **/
    let running = false;
    let score = 0;
    let misses = 0;

    const lanes = 3;
    const laneWidth = () => width / lanes;
    const zoneHeight = 120;
    const zoneTop = () => height - zoneHeight;
    const circleRadius = 26;

    // Per-lane cooldown + hit animation
    const TAP_COOLDOWN = 0.5;
    let laneCooldownUntil = [0, 0, 0];
    let laneHitFlashUntil = [0, 0, 0]; // short green flash

    let lastLane = -1;
    let currentCircle = null;

    function speedCurve(score) {
        return 260 + Math.pow(score, 1.2) * 25 + (Math.random() - 0.5) * 40;
    }

    function spawnCircle() {
        let lane;
        do {
            lane = Math.floor(Math.random() * lanes);
        } while (lane === lastLane);

        lastLane = lane;
        currentCircle = {
            lane,
            x: lane * laneWidth() + laneWidth() / 2,
            y: -circleRadius * 1.5,
            vy: speedCurve(score)
        };
    }

    function startGame() {
        initAudio();
        running = true;
        score = 0;
        misses = 0;
        laneCooldownUntil = [0,0,0];
        laneHitFlashUntil = [0,0,0];
        hudScore.textContent = score;
        hudMiss.textContent = misses;

        startScreen.style.display = 'none';

        spawnCircle();
        lastTime = performance.now();
        requestAnimationFrame(loop);
    }

    function registerHit(lane) {
        score++;
        hudScore.textContent = score;
        hitSound();
        laneHitFlashUntil[lane] = performance.now()/1000 + 0.15; // flash 0.15s
        spawnCircle();
    }

    function registerMiss() {
        misses++;
        hudMiss.textContent = misses;
        missSound();
        spawnCircle();
    }

    function handleLaneTap(lane) {
        if (!running || !currentCircle) return;

        const nowSec = performance.now() / 1000;

        // Cooldown check
        if (nowSec < laneCooldownUntil[lane]) return;

        // Start lane cooldown timer
        laneCooldownUntil[lane] = nowSec + TAP_COOLDOWN;

        // Only a hit if correct lane **and** inside hit window
        if (lane !== currentCircle.lane) return;

        const top = zoneTop() + 10;
        const bottom = height - 10;

        if (
            currentCircle.y + circleRadius >= top &&
            currentCircle.y - circleRadius <= bottom
        ) {
            registerHit(lane);
        }
    }

    /** INPUT **/
    function handleClick(event) {
        initAudio();
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) * (width / rect.width);
        const y = (event.clientY - rect.top) * (height / rect.height);
        if (y >= zoneTop() - 20) {
            handleLaneTap(Math.floor(x / laneWidth()));
        }
    }

    function handleTouch(event) {
        initAudio();
        const t = event.changedTouches[0];
        const rect = canvas.getBoundingClientRect();
        const x = (t.clientX - rect.left) * (width / rect.width);
        const y = (t.clientY - rect.top) * (height / rect.height);
        if (y >= zoneTop() - 20) {
            handleLaneTap(Math.floor(x / laneWidth()));
        }
        event.preventDefault();
    }

    function handleKey(event) {
        initAudio();
        if (!running) return;
        if (event.key === 'a') handleLaneTap(0);
        if (event.key === 's') handleLaneTap(1);
        if (event.key === 'd') handleLaneTap(2);
    }

    canvas.addEventListener('mousedown', handleClick);
    canvas.addEventListener('touchstart', handleTouch, {passive:false});
    window.addEventListener('keydown', handleKey);
    startButton.addEventListener('click', startGame);

    /** GAME LOOP **/
    let lastTime = 0;

    function loop(ts) {
        if (!running) return;
        const dt = (ts - lastTime) / 1000;
        lastTime = ts;

        if (currentCircle) {
            currentCircle.y += currentCircle.vy * dt;
            if (currentCircle.y - circleRadius > height) {
                registerMiss();
            }
        }

        draw();
        requestAnimationFrame(loop);
    }

    /** DRAW **/
    function draw() {
        ctx.clearRect(0,0,width,height);

        // Background
        const grad = ctx.createLinearGradient(0,0,0,height);
        grad.addColorStop(0,'#000');
        grad.addColorStop(1,'#111');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,width,height);

        // Lane separators
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 2;
        for (let i=1;i<lanes;i++){
            let x = i * laneWidth();
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }

        // Hit zone
        ctx.fillStyle='rgba(255,255,255,0.06)';
        ctx.fillRect(0, zoneTop(), width, zoneHeight);

        // Bottom lane boxes with cooldown/hit effects
        const nowSec = performance.now() / 1000;

        for (let lane = 0; lane < lanes; lane++) {
            const x0 = lane * laneWidth() + 4;
            const y0 = height - 24;
            const w  = laneWidth() - 8;
            const h  = 20;

            if (nowSec < laneHitFlashUntil[lane]) {
                // GREEN flash for hit
                ctx.fillStyle = 'rgba(76, 175, 80, 0.85)';
                ctx.fillRect(x0, y0, w, h);
                ctx.strokeStyle = 'rgba(76,175,80,1.0)';
                ctx.lineWidth = 3;
                ctx.strokeRect(x0, y0, w, h);
            }
            else if (nowSec < laneCooldownUntil[lane]) {
                // RED cooldown
                ctx.fillStyle = 'rgba(244, 67, 54, 0.65)';
                ctx.fillRect(x0, y0, w, h);
                ctx.strokeStyle = 'rgba(244, 67, 54, 1.0)';
                ctx.lineWidth = 3;
                ctx.strokeRect(x0, y0, w, h);
            }
            else {
                // Normal box
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x0, y0, w, h);
            }
        }

        // Circle
        if (currentCircle) {
            const colors = ['#26c6da','#66bb6a','#ffca28'];
            ctx.fillStyle = colors[currentCircle.lane];
            ctx.beginPath();
            ctx.arc(currentCircle.x, currentCircle.y, circleRadius, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle='rgba(0,0,0,0.5)';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }

})();
</script>
</body>
</html>
